---
layout: post
title: "secs2覚え書き"
date: 2025-11-13 00:00:00
---

## secs2
バイナリデータをデコードしたいが仕様がわからないので、A.I製でテストしてみる用

#!/usr/bin/env python3
"""
SECS-II バイナリ/CSVファイル -> SML テキスト変換ツール (日時・方向・SxFy・Select 出力対応)

使い方:
  python secs2_file_converter_sml.py input_file output_file

機能:
- 生バイナリ、16進テキスト、CSVログ（末尾に16進トークンが並ぶ形式）に対応。
- CSV行から日時（例: "2025/11/11/" と "21:00:01"）と送受信方向 ("Recv"/"Send") を抽出して
  出力の先頭に出力します。
- "Send" 行の次カラムに SxFy (例: S6F11) があれば、それを出力先頭に表示します。
- "Recv" 行の次カラムに Select 等のコマンドがあれば、それも出力先頭に表示します。
- SECS-II をパースして SML 形式で出力します（LIST/A/B/U1/I4/... を対応）。
- 複数行入力ならメッセージ毎に SML を出力し、メッセージ間に空行を挿入します。
"""
from typing import Tuple, Any, List
import struct
import sys
import csv
import re
import io

# マップ: フォーマット上位6bit -> (SML tag, item byte size or None)
SECS2_FORMATS = {
    0x00: ("B", None),    # BINARY
    0x10: ("L", None),    # LIST
    0x20: ("BOOLEAN", 1),
    0x24: ("A", 1),       # ASCII
    0x25: ("J", 1),       # JIS8 (Jを仮定)
    0x30: ("I8", 8),
    0x38: ("I1", 1),
    0x40: ("I2", 2),
    0x48: ("I4", 4),
    0x50: ("F8", 8),
    0x54: ("F4", 4),
    0x60: ("U8", 8),
    0x68: ("U1", 1),
    0x70: ("U2", 2),
    0x78: ("U4", 4),
}

HEX_TOKEN_RE = re.compile(r'^[0-9A-Fa-f]+$')
HEX_FIELD_RE = re.compile(r'^[0-9A-Fa-f,\s]+$')  # カンマや空白を含む hex フィールド
SXY_RE = re.compile(r'^[sS]\d+[fF]\d+$')         # SxFy パターン（例: S6F11）
DATE_RE = re.compile(r'^\d{4}/\d{1,2}/\d{1,2}/?$')  # 2025/11/11 or 2025/11/11/
TIME_RE = re.compile(r'^\d{2}:\d{2}:\d{2}$')        # 21:00:01
DIRECTION_RE = re.compile(r'^(Recv|Send)$', re.IGNORECASE)

def _read_length(data: bytes, pos: int, length_bytes_count: int) -> Tuple[int, int]:
    if length_bytes_count <= 0:
        return 0, pos
    if pos + length_bytes_count > len(data):
        raise ValueError("length field runs off end of buffer")
    length = int.from_bytes(data[pos:pos+length_bytes_count], "big")
    return length, pos + length_bytes_count

def parse_secs2_element(data: bytes, pos: int=0) -> Tuple[dict, int]:
    if pos >= len(data):
        raise ValueError("parse past end")
    first = data[pos]
    fmt = first & 0b11111100
    length_type = first & 0b11
    pos += 1
    length_bytes_count = length_type + 1
    typename, itemsize = SECS2_FORMATS.get(fmt, (f"UNKNOWN_{hex(fmt)}", None))

    if fmt == 0x10:  # LIST
        length, pos = _read_length(data, pos, length_bytes_count)
        items = []
        for _ in range(length):
            el, pos = parse_secs2_element(data, pos)
            items.append(el)
        return {"type": "LIST", "length": length, "value": items}, pos

    length, pos = _read_length(data, pos, length_bytes_count)
    if pos + length > len(data):
        raise ValueError("value runs off end of buffer")
    val_bytes = data[pos:pos+length]

    if fmt == 0x00:  # BINARY
        value = list(val_bytes)
    elif fmt == 0x20:  # BOOLEAN
        value = [bool(b) for b in val_bytes]
    elif fmt == 0x24:  # ASCII
        try:
            value = val_bytes.decode("ascii", errors="replace")
        except Exception:
            value = val_bytes.decode("latin1", errors="replace")
    elif fmt == 0x25:  # JIS8 (ISO-2022-JP 想定)
        try:
            value = val_bytes.decode("iso2022_jp", errors="replace")
        except Exception:
            value = val_bytes.decode("latin1", errors="replace")
    elif fmt in (0x38, 0x40, 0x48, 0x30):  # I1, I2, I4, I8
        size = {0x38:1,0x40:2,0x48:4,0x30:8}[fmt]
        vals = []
        if size == 1:
            for b in val_bytes:
                vals.append(struct.unpack(">b", bytes([b]))[0])
        else:
            n = len(val_bytes) // size
            for i in range(n):
                chunk = val_bytes[i*size:(i+1)*size]
                if size == 2:
                    vals.append(struct.unpack(">h", chunk)[0])
                elif size == 4:
                    vals.append(struct.unpack(">i", chunk)[0])
                elif size == 8:
                    vals.append(struct.unpack(">q", chunk)[0])
        value = vals if len(vals) != 1 else vals[0]
    elif fmt in (0x68, 0x70, 0x78, 0x60):  # U1, U2, U4, U8
        size = {0x68:1,0x70:2,0x78:4,0x60:8}[fmt]
        if size == 1:
            vals = [b for b in val_bytes]
        else:
            n = len(val_bytes) // size
            vals = []
            for i in range(n):
                chunk = val_bytes[i*size:(i+1)*size]
                if size == 2:
                    vals.append(struct.unpack(">H", chunk)[0])
                elif size == 4:
                    vals.append(struct.unpack(">I", chunk)[0])
                elif size == 8:
                    vals.append(struct.unpack(">Q", chunk)[0])
        value = vals if len(vals) != 1 else vals[0]
    elif fmt == 0x54:  # F4
        n = len(val_bytes) // 4
        vals = [struct.unpack(">f", val_bytes[i*4:(i+1)*4])[0] for i in range(n)]
        value = vals if len(vals) != 1 else vals[0]
    elif fmt == 0x50:  # F8
        n = len(val_bytes) // 8
        vals = [struct.unpack(">d", val_bytes[i*8:(i+1)*8])[0] for i in range(n)]
        value = vals if len(vals) != 1 else vals[0]
    else:
        value = list(val_bytes)

    pos += length
    return {"type": typename, "length": length, "value": value}, pos

def parse_all(data: bytes) -> List[dict]:
    pos = 0
    items = []
    while pos < len(data):
        el, pos = parse_secs2_element(data, pos)
        items.append(el)
    return items

# ---------------------
# SML へのシリアライズ
# ---------------------

def _escape_sml_string(s: str) -> str:
    s2 = s.replace("\\", "\\\\").replace('"', '\\"')
    out = []
    for ch in s2:
        code = ord(ch)
        if 0x20 <= code <= 0x7e:
            out.append(ch)
        else:
            out.append(f"\\x{code:02x}")
    return "".join(out)

def _format_binary_bytes_as_hex(bytes_list: List[int]) -> str:
    if not bytes_list:
        return ""
    return " ".join(f"0x{b:02X}" for b in bytes_list)

def element_to_sml(el: dict, indent: int = 0) -> str:
    pad = "  " * indent
    t = el.get("type")
    if t == "LIST" or t == "L":
        lines = [f"{pad}LIST [{el.get('length')}]"]
        children = el.get("value", [])
        for child in children:
            lines.append(element_to_sml(child, indent + 1))
        return "\n".join(lines)
    tag = t
    if t.startswith("UNKNOWN_"):
        tag = t
    else:
        tag = t
    val = el.get("value")
    if isinstance(val, str):
        esc = _escape_sml_string(val)
        return f"{pad}<{tag} \"{esc}\">"
    if isinstance(val, list):
        if tag == "B" or tag == "BINARY":
            hexs = _format_binary_bytes_as_hex(val)
            return f"{pad}<{tag} {hexs}>"
        else:
            if all(isinstance(x, str) for x in val):
                items = " ".join(f"\"{_escape_sml_string(x)}\"" for x in val)
                return f"{pad}<{tag} [{items}]>"
            else:
                items = " ".join(str(x) for x in val)
                return f"{pad}<{tag} [{items}]>"
    if tag == "B" or tag == "BINARY":
        if isinstance(val, int):
            return f"{pad}<{tag} 0x{val:02X}>"
        if isinstance(val, bytes):
            return f"{pad}<{tag} 0x{val.hex().upper()}>"
    if isinstance(val, bool):
        return f"{pad}<{tag} {str(val)}>"
    if isinstance(val, (int, float)):
        return f"{pad}<{tag} {val}>"
    return f"{pad}<{tag} {val}>"

def items_to_sml_text(items: List[dict]) -> str:
    lines = []
    for el in items:
        if el.get("type") == "LIST":
            lines.append(f"LIST [{el.get('length')}]")
            children = el.get("value", [])
            for child in children:
                lines.append(element_to_sml(child, 1))
        else:
            lines.append(element_to_sml(el, 0))
    return "\n".join(lines)

# ---------------------
# CSV/行処理ユーティリティ
# ---------------------

def is_hex_token(s: str) -> bool:
    return bool(HEX_TOKEN_RE.fullmatch(s))

def is_hex_field(s: str) -> bool:
    # カンマや空白で区切られた hex トークン列かを判定
    if s is None:
        return False
    s2 = s.strip()
    if s2 == "":
        return False
    # 全体が hex, comma, space のみで構成されているか
    if not HEX_FIELD_RE.fullmatch(s2):
        return False
    # 各パートが hex トークンか
    parts = re.split(r'[, \t]+', s2)
    return all(p != "" and HEX_TOKEN_RE.fullmatch(p) for p in parts)

def extract_bytes_from_csv_row(row: List[str]) -> bytes:
    """
    CSV の1行（fieldsのリスト）から、末尾にある hex/binary 部分を抽出して bytes を返す。
    """
    if not row:
        raise ValueError("empty row")
    # 後ろから連続して hex フィールドっぽいものを集める
    i = len(row) - 1
    tokens: List[str] = []
    while i >= 0:
        f = row[i]
        if f is None:
            break
        s = str(f).strip()
        if s == "":
            i -= 1
            continue
        if is_hex_field(s):
            parts = re.split(r'[, \t]+', s)
            parts = [p for p in parts if p != ""]
            tokens[:0] = parts  # 前に追加
            i -= 1
            continue
        break

    if not tokens:
        raise ValueError("no hex tokens found in CSV row")
    hexchars = "".join(tokens)
    hexchars = re.sub(r'0x', '', hexchars, flags=re.IGNORECASE)
    hexchars = re.sub(r'\s+', '', hexchars)
    if len(hexchars) % 2 != 0:
        hexchars = '0' + hexchars
    try:
        return bytes.fromhex(hexchars)
    except Exception as e:
        raise ValueError(f"failed to parse hex from tokens ({e})")

def _find_sx_fy_in_row(row: List[str]) -> str:
    """
    Send カラムの次に SxFy があればそれを返す。
    見つからなければ行内で SxFy 形式のトークンを探索して返す（最初に見つかったもの）。
    見つからなければ空文字を返す。
    """
    for i, v in enumerate(row):
        if v is None:
            continue
        vs = str(v).strip()
        if vs.lower() == "send" and i + 1 < len(row):
            cand = str(row[i+1]).strip().strip('"').strip()
            if SXY_RE.fullmatch(cand):
                return cand.upper()
    # 見つからなければ行内全体を検索
    for v in row:
        if v is None:
            continue
        cand = str(v).strip().strip('"').strip()
        if SXY_RE.fullmatch(cand):
            return cand.upper()
    return ""

def _find_select_in_row(row: List[str]) -> str:
    """
    Recv カラムの次にある Select 等のコマンドを返す（空白/引用符をトリム）。
    見つからなければ空文字を返す。
    例: ["2025/...","21:00:01","Recv","Select","10,02,..."] -> "Select"
    """
    for i, v in enumerate(row):
        if v is None:
            continue
        vs = str(v).strip()
        if vs.lower() == "recv" and i + 1 < len(row):
            cand = str(row[i+1]).strip().strip('"').strip()
            # cand が hex フィールドだけの場合は Select が無いと判断
            if cand == "":
                return ""
            # もし cand が SxFy のようなら Select ではない
            if SXY_RE.fullmatch(cand):
                return ""
            # もし cand が hex トークン列なら Select ではない
            if is_hex_field(cand):
                return ""
            return cand
    # 見つからなければ空文字
    return ""

def _find_sx_fy_or_select_in_row(row: List[str]) -> Tuple[str, str]:
    """
    行から SxFy（Send時）および Select（Recv時）を抽出して返す。
    (sx_fy, select_cmd)
    """
    sx = _find_sx_fy_in_row(row)
    sel = _find_select_in_row(row)
    return sx, sel

def _extract_timestamp_and_direction(row: List[str]) -> Tuple[str, str, str]:
    """
    CSV 行から (date_str, time_str, direction) を抽出する。
    見つからなければ空文字を返す。
    - date: 例 "2025/11/11/" -> "2025/11/11"
    - time: 例 "21:00:01"
    - direction: "Recv" または "Send"（大文字小文字問わず）
    """
    date = ""
    time = ""
    direction = ""
    # まず先頭数カラムをチェック（よくある配置: date, time, direction, ...）
    if len(row) >= 1:
        s0 = str(row[0]).strip().strip('"')
        if DATE_RE.fullmatch(s0):
            date = s0.rstrip('/')
    if len(row) >= 2:
        s1 = str(row[1]).strip().strip('"')
        if TIME_RE.fullmatch(s1):
            time = s1
    # direction（Recv/Send）はどこにあってもよいので全文検索
    for v in row:
        if v is None:
            continue
        vs = str(v).strip().strip('"')
        m = DIRECTION_RE.fullmatch(vs)
        if m:
            direction = m.group(1).capitalize()
            break
    # もし date/time が見つかっていなければ、行内のトークンを探す（柔軟に）
    if not date:
        for v in row[:4]:  # 最初の数カラムを探す
            if v is None:
                continue
            vs = str(v).strip().strip('"')
            if DATE_RE.fullmatch(vs):
                date = vs.rstrip('/')
                break
    if not time:
        for v in row[:6]:
            if v is None:
                continue
            vs = str(v).strip().strip('"')
            if TIME_RE.fullmatch(vs):
                time = vs
                break
    return date, time, direction

# ---------------------
# 入力ファイル判定と変換処理
# ---------------------

def process_text_file_lines_to_sml(text: str) -> List[str]:
    """
    テキストファイルの内容を行単位に処理し、各行からバイナリbyteを取り出して SML に変換。
    戻り値: 各メッセージの SML テキスト（リスト）
    """
    out_texts: List[str] = []
    reader = csv.reader(io.StringIO(text))
    for rowno, row in enumerate(reader, start=1):
        if not row:
            continue
        try:
            # 日時・方向・SxFy・Select を抽出
            date, time, direction = _extract_timestamp_and_direction(row)
            sx_fy, select_cmd = _find_sx_fy_or_select_in_row(row)

            # 行全体が単一の hex テキストか (例: "10 02 24 04 ...")
            if len(row) == 1:
                s = row[0].strip()
                if is_hex_field(s):
                    hexchars = re.sub(r'0x', '', "".join(re.split(r'[, \t]+', s)))
                    hexchars = re.sub(r'\s+', '', hexchars)
                    if len(hexchars) % 2 != 0:
                        hexchars = '0' + hexchars
                    data = bytes.fromhex(hexchars)
                    items = parse_all(data)
                    sml = items_to_sml_text(items)
                    header_lines = []
                    if date or time or direction:
                        dt = f"{date} {time}".strip()
                        header_lines.append(f"Date: {dt}" if dt else "Date:")
                        if direction:
                            header_lines[-1] += f"  Direction: {direction}"
                    if sx_fy:
                        header_lines.append(f"SxFy: {sx_fy}")
                    if select_cmd:
                        header_lines.append(f"Select: {select_cmd}")
                    if header_lines:
                        sml = "\n".join(header_lines) + "\n" + sml
                    out_texts.append(sml)
                    continue

            # それ以外は CSV の末尾に hex トークンが並んでいる想定で抽出
            data = extract_bytes_from_csv_row(row)
            items = parse_all(data)
            sml = items_to_sml_text(items)
            header_lines = []
            if date or time or direction:
                dt = f"{date} {time}".strip()
                header_lines.append(f"Date: {dt}" if dt else "Date:")
                if direction:
                    header_lines[-1] += f"  Direction: {direction}"
            if sx_fy:
                header_lines.append(f"SxFy: {sx_fy}")
            if select_cmd:
                header_lines.append(f"Select: {select_cmd}")
            if header_lines:
                sml = "\n".join(header_lines) + "\n" + sml
            out_texts.append(sml)
        except Exception as e:
            out_texts.append(f"# Row {rowno}: parse error: {e}")
    return out_texts

def process_binary_file_to_sml(path: str) -> List[str]:
    data = open(path, "rb").read()
    items = parse_all(data)
    return [items_to_sml_text(items)]

def process_hex_text_file_to_sml(path: str) -> List[str]:
    raw = open(path, "rb").read()
    s = raw.decode("ascii", errors="ignore")
    s_strip = s.strip()
    if s_strip != "" and all(c in "0123456789abcdefABCDEF \t\r\n,\"" for c in s_strip):
        hexchars = re.sub(r'[,\s"]+', '', s_strip)
        hexchars = re.sub(r'0x', '', hexchars, flags=re.IGNORECASE)
        if len(hexchars) % 2 != 0:
            hexchars = '0' + hexchars
        try:
            data = bytes.fromhex(hexchars)
            items = parse_all(data)
            return [items_to_sml_text(items)]
        except Exception:
            return process_text_file_lines_to_sml(s)
    else:
        return process_text_file_lines_to_sml(s)

def main():
    import argparse
    p = argparse.ArgumentParser(description="SECS-II binary/CSV -> SML converter (includes Date/Time, Direction, SxFy, Select when present)")
    p.add_argument("input", help="input file (raw binary, hex-text, or CSV log)")
    p.add_argument("output", help="output file (SML text)")
    args = p.parse_args()

    with open(args.input, "rb") as f:
        sample = f.read(4096)
    is_mostly_binary = any(b == 0 for b in sample)
    try:
        if is_mostly_binary:
            sml_texts = process_binary_file_to_sml(args.input)
        else:
            sml_texts = process_hex_text_file_to_sml(args.input)
    except Exception as e:
        print("Fatal parse error:", e, file=sys.stderr)
        sys.exit(2)

    with open(args.output, "w", encoding="utf-8") as f:
        for i, txt in enumerate(sml_texts):
            f.write(txt)
            if not txt.endswith("\n"):
                f.write("\n")
            if i != len(sml_texts) - 1:
                f.write("\n")

if __name__ == "__main__":
    main()
