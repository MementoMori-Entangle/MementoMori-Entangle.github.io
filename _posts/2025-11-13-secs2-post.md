---
layout: post
title: "secs2覚え書き"
date: 2025-11-13 00:00:00
---

## secs2
バイナリデータをデコードしたいが仕様がわからないので、A.I製でテストしてみる用

import struct

SECS2_FORMATS = {
    0x00: ("BINARY", 1),
    0x10: ("LIST", None),
    0x20: ("BOOLEAN", 1),
    0x24: ("ASCII", 1),
    0x25: ("JIS8", 1),
    0x30: ("I8", 8),
    0x38: ("I1", 1),
    0x40: ("I2", 2),
    0x48: ("I4", 4),
    0x50: ("F8", 8),
    0x54: ("F4", 4),
    0x60: ("U8", 8),
    0x68: ("U1", 1),
    0x70: ("U2", 2),
    0x78: ("U4", 4),
}

def parse_secs2(data, pos=0, depth=0):
    indent = "  " * depth
    if pos >= len(data):
        return pos
    fmt = data[pos] & 0b11111100
    length_type = data[pos] & 0b11
    pos += 1
    # 長さ読み取り
    if fmt == 0x10: # LIST
        if length_type == 0:
            length = data[pos]
            pos += 1
        elif length_type == 1:
            length = struct.unpack(">H", data[pos:pos+2])[0]
            pos += 2
        elif length_type == 2:
            length = struct.unpack(">I", b'\x00' + data[pos:pos+3])[0]
            pos += 3
        else:
            length = 0
        print(f"{indent}LIST [{length}]")
        for _ in range(length):
            pos = parse_secs2(data, pos, depth+1)
        return pos

    if length_type == 0:
        length = data[pos]
        pos += 1
    elif length_type == 1:
        length = struct.unpack(">H", data[pos:pos+2])[0]
        pos += 2
    elif length_type == 2:
        length = struct.unpack(">I", b'\x00' + data[pos:pos+3])[0]
        pos += 3
    else:
        length = 0

    typename, itemsize = SECS2_FORMATS.get(fmt, (f"UNKNOWN_{hex(fmt)}", 1))

    val_bytes = data[pos:pos+length]

    if fmt in (0x24, 0x25): # ASCII or JIS8
        try:
            if fmt == 0x24:
                val = val_bytes.decode("ascii", errors="replace")
                print(f"{indent}ASCII: {val!r}")
            else:
                val = val_bytes.decode("iso2022_jp", errors="replace")
                print(f"{indent}JIS8: {val!r}")
        except Exception as e:
            print(f"{indent}{typename}: decode error - {e}")
    elif fmt == 0x00: # BINARY
        print(f"{indent}BINARY: {list(val_bytes)}")
    elif fmt == 0x20: # BOOLEAN
        print(f"{indent}BOOLEAN: {[bool(b) for b in val_bytes]}")
    elif fmt in (0x38, 0x40, 0x48, 0x30): # I1, I2, I4, I8
        vals = []
        n = length // itemsize
        for i in range(n):
            if fmt == 0x38:
                vals.append(struct.unpack('>b', val_bytes[i*1:(i+1)*1])[0])
            elif fmt == 0x40:
                vals.append(struct.unpack('>h', val_bytes[i*2:(i+1)*2])[0])
            elif fmt == 0x48:
                vals.append(struct.unpack('>i', val_bytes[i*4:(i+1)*4])[0])
            elif fmt == 0x30:
                vals.append(struct.unpack('>q', val_bytes[i*8:(i+1)*8])[0])
        print(f"{indent}{typename}: {vals}")
    elif fmt in (0x68, 0x70, 0x78, 0x60): # U1, U2, U4, U8
        vals = []
        n = length // itemsize
        for i in range(n):
            if fmt == 0x68:
                vals.append(struct.unpack('>B', val_bytes[i*1:(i+1)*1])[0])
            elif fmt == 0x70:
                vals.append(struct.unpack('>H', val_bytes[i*2:(i+1)*2])[0])
            elif fmt == 0x78:
                vals.append(struct.unpack('>I', val_bytes[i*4:(i+1)*4])[0])
            elif fmt == 0x60:
                vals.append(struct.unpack('>Q', val_bytes[i*8:(i+1)*8])[0])
        print(f"{indent}{typename}: {vals}")
    elif fmt == 0x54: # F4
        n = length // 4
        vals = [struct.unpack('>f', val_bytes[i*4:(i+1)*4])[0] for i in range(n)]
        print(f"{indent}F4: {vals}")
    elif fmt == 0x50: # F8
        n = length // 8
        vals = [struct.unpack('>d', val_bytes[i*8:(i+1)*8])[0] for i in range(n)]
        print(f"{indent}F8: {vals}")
    else:
        print(f"{indent}{typename}: {list(val_bytes)}")

    pos += length
    return pos

if __name__ == "__main__":
    sample = bytes.fromhex(
        "10 04 "                  # LIST, 4 items
        "24 05 48656c6c6f "       # ASCII "Hello"
        "68 03 010203 "           # U1 [1,2,3]
        "48 04 0000002a "         # I4 [42]
        "50 08 3ff199999999999a " # F8 [1.1]
    )
    sample = bytes.fromhex("10 02 24 04 31 30 30 31 00 01 00")
    parse_secs2(sample)
